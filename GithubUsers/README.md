# Домашнее задание 2.
Реализуйте экран пользователя, на котором отобразите его логин. Переход на экран осуществите по клику на пользователя в списке через router.navigateTo.

# Получившийся результат.

Что было сделано:
1. Внёс изменения в IScreens, добавил новый метод user(userId: Int). Реализовал его в классе AndroidScreens.
2. Внёс изменения в UsersPresenter, теперь в конструкторе этот класс принимает IScreens для осуществления перехода на экран конкретного пользователя. Реализовал переход через router.navigateTo. Переделал вызов конструктора UsersPresenter в UsersFragment.
3. Добавил в класс GithubUser свойство id для дальнейшего использования.
4. Внёс изменения в класс GithubUsersRepository, добавил функцию getUserById, которая возвращает GithubUser по userId.
5. Создан новый интерфейс UserView с функцией updateView, которая принимает GithubUser.
6. Создан новый фрагмент UserFragment, который при создании через newInstance принимает userId и хранит его в аргументах. Также новый фрагмент реализует функцию updateView интерфейса UserView.
7. Реализован новый класс UserPresenter, в котором во время onFirstViewAttach происходит загрузка данных и отображение через viewState.updateView.

# Домашнее задание 3.
1. Переделайте взаимодействие модели и логики в коде из второго урока на Rx-паттерн.
2. \* Самостоятельно изучите оператор switchMap. Разберитесь, как он работает и чем отличается от flatMap. Сформулируйте и напишите ответ в комментарии к практическому заданию. Для экспериментов воспользуйтесь приведённым на уроке примером с flatMap, замените его на switchMap, а остальное оставьте без изменений.

# Получившийся результат.

Что было сделано:
1. Внёс изменения в GithubUsersRepository. Теперь функции getUsers() и getUserById() будут возвращать Observable.
2. Внёс изменения в UsersPresenter и UserPresenter. Переделал на взаимодействие с Observable.

Если flatMap из каждого элемента создаёт новый источник, после чего выполняет слияние этих источников, похожее на применение над ними оператора merge, то  switchMap по сути берет последний сгенерированный Observable, а от предыдущих отписывается.